RN   = max(0, W_vec["RN"]   + lambda["RN"]   - serve_RN),
RRev = max(0, W_vec["RRev"] + lambda["RRev"] - serve_RRev)
)
alloc <- c(UN=serve_UN, URev=serve_URev, SN=serve_SN, SRev=serve_SRev, RN=serve_RN, RRev=serve_RRev)
list(next_W = next_W, alloc = alloc)
}
# -----------------------
# 2) Steady-state weekly snapshot for bars (while UN has backlog)
#    - Assume UN and SN have large backlogs so they can absorb service.
#    - Unmet is computed vs weekly inflow (for a "typical" week).
# -----------------------
allocation_snapshot <- function(UN_quota,
W_for_snapshot = c(UN=1e9, URev=0, SN=1e9, SRev=0, RN=0, RRev=0)) {
step  <- allocate_one_week(UN_quota, W_for_snapshot)
alloc <- step$alloc
# While UN has backlog, unmet vs inflow for UN is 0; for others unmet = max(0, inflow - served)
unmet <- pmax(0, lambda - pmin(lambda, alloc))
tibble(Class = factor(names(alloc), levels = classes),
Allocated = as.numeric(alloc),
Unmet     = as.numeric(unmet))
}
# Build allocation bar data for the four scenarios
alloc_bar_df <- bind_rows(lapply(names(scenarios), function(nm){
allocation_snapshot(scenarios[[nm]]) %>% mutate(Scenario = nm)
})) %>%
pivot_longer(cols = c(Allocated, Unmet), names_to = "Metric", values_to = "Value") %>%
mutate(Scenario = factor(Scenario, levels = names(scenarios)),
Class    = factor(Class,    levels = classes),
Metric   = factor(Metric,   levels = c("Allocated","Unmet")))
# Plot (A): Allocated vs Unmet (bars)
p_alloc <- ggplot(alloc_bar_df, aes(x = Class, y = Value, fill = Metric)) +
geom_col(position = position_dodge(width = 0.7), width = 0.7) +
geom_text(aes(label = number(Value, accuracy = 1)),
position = position_dodge(width = 0.7),
vjust = -0.35, size = 3.6, fontface = "bold") +
facet_wrap(~ Scenario, ncol = 2, scales = "free_y") +
labs(
title    = "Allocated vs Unmet — New caps 17/18/19/20 (spill leftover to SN; RN = 0)",
subtitle = paste("Clinic: 2078B | Weekly capacity:", S, "| New-total cap:", NEW_TOTAL_CAP),
x = NULL, y = "Cases per week"
) +
scale_y_continuous(expand = expansion(mult = c(0.02, 0.12))) +
theme_minimal(base_size = 12) +
theme(legend.position = "top")
print(p_alloc)
# -----------------------
# 3) 15-year (780 weeks) simulation per scenario
# -----------------------
simulate_scenario <- function(UN_quota, horizon_weeks = 780L) {
W <- W0
traj  <- tibble(Week = 0L, Class = classes, Backlog = as.numeric(W))
sched <- list()
for (t in 1:horizon_weeks) {
step <- allocate_one_week(UN_quota, W)
W    <- step$next_W
# record backlog
traj <- bind_rows(traj, tibble(Week = t, Class = classes, Backlog = as.numeric(W)))
# record allocation
sched[[t]] <- tibble(Week = t, Class = classes, Served = as.numeric(step$alloc[classes]))
}
schedule_tbl <- bind_rows(sched)
# first week UN becomes zero (if never clears within horizon, return NA)
t_clear <- {
hits <- traj %>% filter(Class=="UN", Backlog == 0) %>% pull(Week)
if (length(hits) == 0) NA_integer_ else min(hits)
}
list(traj = traj, schedule = schedule_tbl, t_clear = t_clear)
}
sim_list <- lapply(scenarios, simulate_scenario)
# Facet labels "(needs X weeks)"
needs_weeks <- sapply(sim_list, function(x) x$t_clear)
facet_labels <- ifelse(is.na(needs_weeks),
paste0(names(needs_weeks), " (needs —)"),
paste0(names(needs_weeks), " (needs ", needs_weeks, " weeks)"))
names(facet_labels) <- names(scenarios)
# Build data to plot backlog lines
traj_df <- bind_rows(lapply(names(sim_list), function(nm){
sim_list[[nm]]$traj %>% mutate(Scenario = nm)
})) %>%
mutate(Scenario = factor(Scenario, levels = names(scenarios), labels = facet_labels),
Class    = factor(Class, levels = classes))
# Plot (B): backlog trajectories (six classes)
p_traj <- ggplot(traj_df, aes(x = Week, y = Backlog, color = Class)) +
geom_line(linewidth = 1.0) +
facet_wrap(~ Scenario, ncol = 2, scales = "free_y") +
labs(
title    = "Backlog trajectories over 15 years (780 weeks)",
subtitle = "Rule: UN quota first; then URev → SRev → RRev; if capacity left and New<20/wk, spill to SN; RN=0",
x        = "Week",
y        = "Backlog (cases)"
) +
scale_y_continuous(labels = label_comma()) +
theme_minimal(base_size = 12) +
theme(legend.position = "right")
print(p_traj)
# -----------------------
# 4) Summary tables
# -----------------------
# 4.1 Weeks to clear UN per scenario
summary_tbl <- tibble(
Scenario             = names(scenarios),
UN_quota_perWeek     = as.integer(unname(scenarios)),
New_total_cap_perWeek= NEW_TOTAL_CAP,
Weeks_to_Clear_UN    = as.integer(needs_weeks)
) %>% arrange(UN_quota_perWeek)
cat("\n=== Weeks to clear UN (by scenario) ===\n")
print(summary_tbl)
# 4.2 Other-class backlogs at the week UN clears (or week 780 if never clears)
t_clear_vec <- sapply(sim_list, function(x) if (is.na(x$t_clear)) 780L else x$t_clear)
other_at_clear <- bind_rows(lapply(names(sim_list), function(nm){
t_star <- t_clear_vec[[nm]]
sim_list[[nm]]$traj %>%
filter(Week == t_star, Class != "UN") %>%
mutate(Scenario = nm) %>%
select(Scenario, Class, Backlog)
})) %>%
pivot_wider(names_from = Class, values_from = Backlog) %>%
arrange(factor(Scenario, levels = names(scenarios)))
cat("\n=== Other-class backlogs at UN-clear week (or week 780 if never clears) ===\n")
print(other_at_clear)
# 4.3 Reallocation metric: sum of SN service up to UN-clear week, as negative "extra" for URev
uRev_realloc_neg <- sapply(names(sim_list), function(nm) {
t_star <- t_clear_vec[[nm]]
sched  <- sim_list[[nm]]$schedule
sn_served <- sched %>%
filter(Class == "SN", Week <= t_star) %>%
summarise(v = sum(Served), .groups = "drop") %>%
pull(v)
-as.integer(sn_served)  # negative to denote "capacity that could be reassigned to URev"
})
final_tbl <- summary_tbl %>%
select(Scenario, UN_quota_perWeek, New_total_cap_perWeek, Weeks_to_Clear_UN) %>%
left_join(other_at_clear, by = "Scenario") %>%
mutate(URev_realloc = as.integer(uRev_realloc_neg[Scenario])) %>%
select(Scenario, UN_quota_perWeek, New_total_cap_perWeek, Weeks_to_Clear_UN,
URev_realloc, URev, SN, SRev, RN, RRev)
cat("\n=== Final summary (includes URev_realloc as negative extra capacity) ===\n")
print(final_tbl)
# ================================================================
# Allocation & Backlog — UN quota (17/18/19/20), all leftover to URev
# Policy per week:
#   1) Serve UN up to its quota (scenario) or need, whichever is smaller.
#   2) Give ALL remaining capacity to URev (no cap).
#   3) SRev -> RRev only if capacity somehow still remains (rare in this policy).
#   4) SN = 0, RN = 0.
# Capacity S = 39/wk. New-total cap not needed here because SN/RN = 0.
# Inflows: UN=17, URev=9, SN=11, SRev=6, RN=4, RRev=2.
# Initial backlog: UN=680, others=0.
#
# Outputs:
#   (A) Allocated vs Unmet bars (steady-state snapshot while UN has backlog)
#   (B) 15-year backlog lines with facet "(needs X weeks)"
#   (C) Summary table: Weeks_to_Clear_UN, backlogs at UN-clear week, and
#       URev_extra (negative) = sum( max(0, URev_served - URev_inflow) ) up to UN-clear.
# ================================================================
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(ggplot2); library(scales); library(purrr)
})
# -----------------------
# Parameters
# -----------------------
S <- 39L
classes <- c("UN","URev","SN","SRev","RN","RRev")
lambda <- c(UN=17, URev=9, SN=11, SRev=6, RN=4, RRev=2)
W0     <- c(UN=680, URev=0, SN=0, SRev=0, RN=0, RRev=0)
scenarios <- c(`New cap = 17`=17L, `New cap = 18`=18L, `New cap = 19`=19L, `New cap = 20`=20L)
# -----------------------
# One-week allocator (leftover to URev)
# -----------------------
allocate_one_week <- function(UN_quota, W_vec) {
# UN need this week = backlog + inflow
need_UN  <- W_vec["UN"] + lambda["UN"]
serve_UN <- min(UN_quota, need_UN)
# All remaining capacity to URev
rem_total <- S - serve_UN
serve_URev <- max(0, rem_total)
rem_total  <- rem_total - serve_URev  # will be 0 in this policy
# The rest (normally zero)
serve_SRev <- min(max(rem_total, 0), lambda["SRev"]); rem_total <- rem_total - serve_SRev
serve_RRev <- min(max(rem_total, 0), lambda["RRev"]); rem_total <- rem_total - serve_RRev
serve_SN <- 0
serve_RN <- 0
# Update backlogs (for URev backlog we only credit up to its inflow)
next_W <- c(
UN   = max(0, W_vec["UN"]   + lambda["UN"]   - serve_UN),
URev = max(0, W_vec["URev"] + lambda["URev"] - min(serve_URev, lambda["URev"])),
SN   = max(0, W_vec["SN"]   + lambda["SN"]   - serve_SN),
SRev = max(0, W_vec["SRev"] + lambda["SRev"] - serve_SRev),
RN   = max(0, W_vec["RN"]   + lambda["RN"]   - serve_RN),
RRev = max(0, W_vec["RRev"] + lambda["RRev"] - serve_RRev)
)
alloc <- c(UN=serve_UN, URev=serve_URev, SN=serve_SN, SRev=serve_SRev, RN=serve_RN, RRev=serve_RRev)
list(next_W = next_W, alloc = alloc)
}
# -----------------------
# Allocation bars snapshot (while UN has backlog)
# -----------------------
allocation_snapshot <- function(UN_quota) {
# Assume UN has large backlog and absorbs its full quota.
serve_UN   <- UN_quota
serve_URev <- max(0, S - serve_UN)
serve_SRev <- 0; serve_RRev <- 0; serve_SN <- 0; serve_RN <- 0
alloc <- c(UN=serve_UN, URev=serve_URev, SN=serve_SN, SRev=serve_SRev, RN=serve_RN, RRev=serve_RRev)
# Unmet vs inflow (URev counts as fully met up to its inflow; extra is not "unmet")
met_for_unmet <- c(UN=serve_UN, URev=min(serve_URev, lambda["URev"]), SN=0, SRev=0, RN=0, RRev=0)
unmet <- pmax(0, lambda - met_for_unmet)
tibble(Class=factor(names(alloc), levels=classes),
Allocated=as.numeric(alloc),
Unmet=as.numeric(unmet))
}
alloc_bar_df <- bind_rows(lapply(names(scenarios), function(nm){
allocation_snapshot(scenarios[[nm]]) %>% mutate(Scenario = nm)
})) %>%
pivot_longer(c(Allocated, Unmet), names_to="Metric", values_to="Value") %>%
mutate(Scenario=factor(Scenario, levels=names(scenarios)),
Class=factor(Class, levels=classes),
Metric=factor(Metric, levels=c("Allocated","Unmet")))
p_alloc <- ggplot(alloc_bar_df, aes(x=Class, y=Value, fill=Metric)) +
geom_col(position=position_dodge(width=0.7), width=0.7) +
geom_text(aes(label=number(Value, accuracy=1)),
position=position_dodge(width=0.7), vjust=-0.35, size=3.6, fontface="bold") +
facet_wrap(~ Scenario, ncol=2, scales="free_y") +
labs(
title="Allocated vs Unmet — UN quotas 17/18/19/20 (all leftover to URev; SN/RN=0)",
subtitle=paste("Clinic: 2078B | Weekly capacity:", S),
x=NULL, y="Cases per week"
) +
scale_y_continuous(expand=expansion(mult=c(0.02,0.12))) +
theme_minimal(base_size=12) +
theme(legend.position="top")
print(p_alloc)
# -----------------------
# 15-year simulation per scenario
# -----------------------
simulate_scenario <- function(UN_quota, horizon_weeks=780L) {
W <- W0
traj  <- tibble(Week=0L, Class=classes, Backlog=as.numeric(W))
sched <- list()
for (t in 1:horizon_weeks) {
step <- allocate_one_week(UN_quota, W)
W    <- step$next_W
traj <- bind_rows(traj, tibble(Week=t, Class=classes, Backlog=as.numeric(W)))
sched[[t]] <- tibble(Week=t, Class=classes, Served=as.numeric(step$alloc[classes]))
}
schedule_tbl <- bind_rows(sched)
# First week UN becomes zero (NA if never clears)
hits <- traj %>% filter(Class=="UN", Backlog==0) %>% pull(Week)
t_clear <- if (length(hits)==0) NA_integer_ else min(hits)
list(traj=traj, schedule=schedule_tbl, t_clear=t_clear)
}
sim_list <- lapply(scenarios, simulate_scenario)
# Facet labels with "(needs X weeks)"
needs_weeks <- sapply(sim_list, function(x) x$t_clear)
facet_labels <- ifelse(is.na(needs_weeks),
paste0(names(needs_weeks), " (needs —)"),
paste0(names(needs_weeks), " (needs ", needs_weeks, " weeks)"))
names(facet_labels) <- names(scenarios)
traj_df <- bind_rows(lapply(names(sim_list), function(nm){
sim_list[[nm]]$traj %>% mutate(Scenario=nm)
})) %>%
mutate(Scenario=factor(Scenario, levels=names(scenarios), labels=facet_labels),
Class=factor(Class, levels=classes))
p_traj <- ggplot(traj_df, aes(x=Week, y=Backlog, color=Class)) +
geom_line(linewidth=1.0) +
facet_wrap(~ Scenario, ncol=2, scales="free_y") +
labs(
title="Backlog trajectories over 15 years (780 weeks)",
subtitle="Rule: UN quota first; ALL leftover to URev; SRev→RRev if any; SN/RN=0",
x="Week", y="Backlog (cases)"
) +
scale_y_continuous(labels=label_comma()) +
theme_minimal(base_size=12) +
theme(legend.position="right")
print(p_traj)
# -----------------------
# Summary tables
# -----------------------
# 1) Weeks to clear UN
summary_tbl <- tibble(
Scenario         = names(scenarios),
UN_quota_perWeek = as.integer(unname(scenarios)),
Weeks_to_Clear_UN= as.integer(needs_weeks)
) %>% arrange(UN_quota_perWeek)
cat("\n=== Weeks to clear UN (by scenario) ===\n"); print(summary_tbl)
# 2) Backlogs of other classes at UN-clear week (or week 780 if never clears)
t_clear_vec <- sapply(sim_list, function(x) if (is.na(x$t_clear)) 780L else x$t_clear)
other_at_clear <- bind_rows(lapply(names(sim_list), function(nm){
t_star <- t_clear_vec[[nm]]
sim_list[[nm]]$traj %>%
filter(Week==t_star, Class!="UN") %>%
mutate(Scenario=nm) %>%
select(Scenario, Class, Backlog)
})) %>%
pivot_wider(names_from=Class, values_from=Backlog) %>%
arrange(factor(Scenario, levels=names(scenarios)))
cat("\n=== Other-class backlogs at UN-clear week (or week 780 if never clears) ===\n")
print(other_at_clear)
# 3) URev_extra (negative): cumulative extra service above its inflow up to UN-clear week
uRev_extra_neg <- sapply(names(sim_list), function(nm){
t_star <- t_clear_vec[[nm]]
sched  <- sim_list[[nm]]$schedule %>% filter(Class=="URev", Week<=t_star)
# extra each week = max(0, served - inflow)
extra <- sum(pmax(0, sched$Served - lambda["URev"]))
-as.integer(extra)
})
final_tbl <- summary_tbl %>%
left_join(other_at_clear, by="Scenario") %>%
mutate(URev_extra = as.integer(uRev_extra_neg[Scenario])) %>%
select(Scenario, UN_quota_perWeek, Weeks_to_Clear_UN,
URev_extra, URev, SN, SRev, RN, RRev)
cat("\n=== Final summary (URev_extra is negative = capacity consumed by URev above inflow) ===\n")
print(final_tbl)
# ================================================================
# Allocation & Backlog — Baseline rule + give any leftover to URev (extra)
# Baseline each week (in order):
#   1) UN up to scenario quota (or need)
#   2) URev up to its inflow (9), then SRev up to 6, RRev up to 2
#   3) If capacity still remains AND total New < 20/wk, give remainder to SN
#   4) RN = 0
#   5) If capacity STILL remains after 1–4, give ALL leftovers to URev as EXTRA
# Notes:
#   - S = 39 per week
#   - Inflows: UN=17, URev=9, SN=11, SRev=6, RN=4, RRev=2
#   - Initial backlog: UN=680; others=0
# Outputs:
#   (A) Allocation bars (Allocated vs Unmet) for scenarios UN quota = 17/18/19/20
#   (B) 15-year (780 weeks) backlog lines with "(needs X weeks)"
#   (C) Summary table: Weeks_to_Clear_UN, other backlogs at that week,
#       URev_extra (negative) = cumulative URev above inflow up to UN-clear
# ================================================================
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(ggplot2); library(scales); library(purrr)
})
# -----------------------
# Parameters
# -----------------------
S <- 39L
NEW_TOTAL_CAP <- 20L  # max total New per week
classes <- c("UN","URev","SN","SRev","RN","RRev")
lambda <- c(UN=17, URev=9, SN=11, SRev=6, RN=4, RRev=2)
W0     <- c(UN=680, URev=0, SN=0, SRev=0, RN=0, RRev=0)
scenarios <- c(`New cap = 17`=17L, `New cap = 18`=18L, `New cap = 19`=19L, `New cap = 20`=20L)
# -----------------------
# One-week allocator = Baseline rule + leftover to URev (extra)
# -----------------------
allocate_one_week <- function(UN_quota, W_vec) {
# Need this week
need_UN <- W_vec["UN"] + lambda["UN"]
need_SN <- W_vec["SN"] + lambda["SN"]
# 1) UN up to quota
serve_UN <- min(UN_quota, need_UN)
new_used <- serve_UN
rem <- S - serve_UN
# 2) Reviews up to inflow (baseline)
serve_URev_base <- min(rem, lambda["URev"]); rem <- rem - serve_URev_base
serve_SRev      <- min(rem, lambda["SRev"]); rem <- rem - serve_SRev
serve_RRev      <- min(rem, lambda["RRev"]); rem <- rem - serve_RRev
# 3) Spill to SN if capacity remains and total New < cap
allow_SN_by_new <- max(0, NEW_TOTAL_CAP - new_used)
serve_SN        <- min(max(rem,0), allow_SN_by_new, need_SN)
new_used <- new_used + serve_SN
rem <- rem - serve_SN
# 4) RN fixed 0
serve_RN <- 0
# 5) Any leftover -> URev EXTRA (above inflow)
serve_URev_extra <- max(0, rem)
rem <- rem - serve_URev_extra  # should be 0
# Totals
serve_URev_total <- serve_URev_base + serve_URev_extra
# Backlog updates (URev backlog reduced by at most its inflow)
next_W <- c(
UN   = max(0, W_vec["UN"]   + lambda["UN"]   - serve_UN),
URev = max(0, W_vec["URev"] + lambda["URev"] - min(serve_URev_total, lambda["URev"])),
SN   = max(0, W_vec["SN"]   + lambda["SN"]   - serve_SN),
SRev = max(0, W_vec["SRev"] + lambda["SRev"] - serve_SRev),
RN   = max(0, W_vec["RN"]   + lambda["RN"]   - serve_RN),
RRev = max(0, W_vec["RRev"] + lambda["RRev"] - serve_RRev)
)
alloc <- c(UN=serve_UN, URev=serve_URev_total, SN=serve_SN, SRev=serve_SRev, RN=serve_RN, RRev=serve_RRev)
extra_uRev <- max(0, serve_URev_total - lambda["URev"])  # for reporting
list(next_W = next_W, alloc = alloc, uRev_extra = extra_uRev)
}
# -----------------------
# Allocation bars snapshot (while UN has backlog)
# -----------------------
allocation_snapshot <- function(UN_quota) {
# Assume UN/SN have backlog, others don't
# Reproduce the same steps but without state
serve_UN <- UN_quota
rem <- S - serve_UN
serve_URev_base <- min(rem, lambda["URev"]); rem <- rem - serve_URev_base
serve_SRev      <- min(rem, lambda["SRev"]); rem <- rem - serve_SRev
serve_RRev      <- min(rem, lambda["RRev"]); rem <- rem - serve_RRev
allow_SN_by_new <- max(0, NEW_TOTAL_CAP - serve_UN)
serve_SN        <- min(max(rem,0), allow_SN_by_new, 1e9)  # backlog large
rem <- rem - serve_SN
serve_RN <- 0
serve_URev_extra <- max(0, rem)
serve_URev_total <- serve_URev_base + serve_URev_extra
alloc <- c(UN=serve_UN, URev=serve_URev_total, SN=serve_SN, SRev=serve_SRev, RN=serve_RN, RRev=serve_RRev)
met_for_unmet <- c(
UN=serve_UN,
URev=min(serve_URev_total, lambda["URev"]),
SN=min(serve_SN, lambda["SN"]),
SRev=min(serve_SRev, lambda["SRev"]),
RN=0, RRev=min(serve_RRev, lambda["RRev"])
)
unmet <- pmax(0, lambda - met_for_unmet)
tibble(Class=factor(names(alloc), levels=classes),
Allocated=as.numeric(alloc),
Unmet=as.numeric(unmet))
}
alloc_bar_df <- bind_rows(lapply(names(scenarios), function(nm){
allocation_snapshot(scenarios[[nm]]) %>% mutate(Scenario = nm)
})) %>%
pivot_longer(c(Allocated, Unmet), names_to="Metric", values_to="Value") %>%
mutate(Scenario=factor(Scenario, levels=names(scenarios)),
Class=factor(Class, levels=classes),
Metric=factor(Metric, levels=c("Allocated","Unmet")))
p_alloc <- ggplot(alloc_bar_df, aes(x=Class, y=Value, fill=Metric)) +
geom_col(position=position_dodge(width=0.7), width=0.7) +
geom_text(aes(label=number(Value, accuracy=1)),
position=position_dodge(width=0.7), vjust=-0.35, size=3.6, fontface="bold") +
facet_wrap(~ Scenario, ncol=2, scales="free_y") +
labs(
title="Allocated vs Unmet — baseline + leftover to URev (SN cap by New≤20; RN=0)",
subtitle=paste("Clinic: 2078B | Weekly capacity:", S),
x=NULL, y="Cases per week"
) +
scale_y_continuous(expand=expansion(mult=c(0.02,0.12))) +
theme_minimal(base_size=12) +
theme(legend.position="top")
print(p_alloc)
# -----------------------
# 15-year simulation per scenario
# -----------------------
simulate_scenario <- function(UN_quota, horizon_weeks=780L) {
W <- W0
traj  <- tibble(Week=0L, Class=classes, Backlog=as.numeric(W))
sched <- list()
extra_vec <- numeric(horizon_weeks)
for (t in 1:horizon_weeks) {
step <- allocate_one_week(UN_quota, W)
W    <- step$next_W
traj <- bind_rows(traj, tibble(Week=t, Class=classes, Backlog=as.numeric(W)))
sched[[t]] <- tibble(Week=t, Class=classes, Served=as.numeric(step$alloc[classes]))
extra_vec[t] <- step$uRev_extra
}
schedule_tbl <- bind_rows(sched)
# first week UN becomes zero (NA if never)
hits <- traj %>% filter(Class=="UN", Backlog==0) %>% pull(Week)
t_clear <- if (length(hits)==0) NA_integer_ else min(hits)
list(traj=traj, schedule=schedule_tbl, extra=extra_vec, t_clear=t_clear)
}
sim_list <- lapply(scenarios, simulate_scenario)
# Facet labels
needs_weeks <- sapply(sim_list, function(x) x$t_clear)
facet_labels <- ifelse(is.na(needs_weeks),
paste0(names(needs_weeks), " (needs —)"),
paste0(names(needs_weeks), " (needs ", needs_weeks, " weeks)"))
names(facet_labels) <- names(scenarios)
traj_df <- bind_rows(lapply(names(sim_list), function(nm){
sim_list[[nm]]$traj %>% mutate(Scenario=nm)
})) %>%
mutate(Scenario=factor(Scenario, levels=names(scenarios), labels=facet_labels),
Class=factor(Class, levels=classes))
p_traj <- ggplot(traj_df, aes(x=Week, y=Backlog, color=Class)) +
geom_line(linewidth=1.0) +
facet_wrap(~ Scenario, ncol=2, scales="free_y") +
labs(
title="Backlog trajectories over 15 years (780 weeks)",
subtitle="Baseline: UN quota → URev/SRev/RRev (to inflow) → SN if New<20 → RN=0; leftover → URev (extra)",
x="Week", y="Backlog (cases)"
) +
scale_y_continuous(labels=label_comma()) +
theme_minimal(base_size=12) +
theme(legend.position="right")
print(p_traj)
# -----------------------
# Summary tables
# -----------------------
summary_tbl <- tibble(
Scenario          = names(scenarios),
UN_quota_perWeek  = as.integer(unname(scenarios)),
Weeks_to_Clear_UN = as.integer(needs_weeks)
) %>% arrange(UN_quota_perWeek)
cat("\n=== Weeks to clear UN (by scenario) ===\n"); print(summary_tbl)
# Backlogs of other classes at UN-clear week (or week 780)
t_clear_vec <- sapply(sim_list, function(x) if (is.na(x$t_clear)) 780L else x$t_clear)
other_at_clear <- bind_rows(lapply(names(sim_list), function(nm){
t_star <- t_clear_vec[[nm]]
sim_list[[nm]]$traj %>%
filter(Week==t_star, Class!="UN") %>%
mutate(Scenario=nm) %>%
select(Scenario, Class, Backlog)
})) %>%
pivot_wider(names_from=Class, values_from=Backlog) %>%
arrange(factor(Scenario, levels=names(scenarios)))
cat("\n=== Other-class backlogs at UN-clear week (or week 780 if never clears) ===\n")
print(other_at_clear)
# URev_extra (negative): cumulative URev > inflow up to UN-clear week
uRev_extra_neg <- sapply(names(sim_list), function(nm){
t_star <- t_clear_vec[[nm]]
-as.integer(sum(sim_list[[nm]]$extra[1:t_star], na.rm = TRUE))
})
final_tbl <- summary_tbl %>%
left_join(other_at_clear, by="Scenario") %>%
mutate(URev_extra = as.integer(uRev_extra_neg[Scenario])) %>%
select(Scenario, UN_quota_perWeek, Weeks_to_Clear_UN,
URev_extra, URev, SN, SRev, RN, RRev)
cat("\n=== Final summary (URev_extra is negative = leftover consumed by URev above inflow) ===\n")
print(final_tbl)
